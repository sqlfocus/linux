#+TITLE: 内核符号表
#+AUTHOR: sqlfocus


本文档简单描述内核符号表的获取方式，备忘！

* 简介
内核符号表由符号名及对应的地址组成，如下：
 #+BEGIN_EXAMPLE
 $ sudo cat /boot/System.map*
    000000000479c4a0 A phys_start
    a000000000000600 A __start_gate_mckinley_e9_patchlist
    a000000000000604 A __end_gate_mckinley_e9_patchlist
 #+END_EXAMPLE
对于系统的oop消息、或者通过gdb的调试消息，都需要根据该对照表，将内核熟悉
的函数地址转化为用户熟悉的函数名称，便于用户进行故障定位、运行监控。

* 存储位置
虽然存储方式不同，但它们的结构一致；并且对应的物理内存地址一致。

** System.map
磁盘中真实存在的文件，存储内核中静态编译的函数和变量地址，每个新编译内核
对应一个System.map文件(如 ~System.map-4.4.0-59-generic~ )。
 - 内核中没有导出的符号名，也有相应的条目
 - 没有动态加载的模块中的符号名
 - 一般只读
 - 固定大小

/proc/kmsg文件保存了内核从最开始启动到正常运行时的所有内核输出消息，是内核
在运行过程中通过printk输出的；如果klogd启动，klogd读取/proc/kmsg文件的内容，
然后通过syslogd程序，写到/var/log/messages文件中；利用dmesg，其实也是读取
/proc/kmsg文件内容，然后显示到终端。
dmesg和klogd都是利用了System.map文件将内核地址转化为对应的函数名称，方便用
户调试。

** /proc/kallsyms
每次内核启动时动态创建，供oops时定位错误，文件大小总为0，包含当前内核导
出的、可供使用的变量或者函数。
 - 实时更新，反映系统当前最新情况
 - 包含已加载模块导出的函数、变量名称
 - 文件动态变化
 - 大小不固定

在内核运行出现问题时，一般由于引用了一个无效指针造成的oops错误，如果在应用
层，一般应用程序不可能从段错误中恢复，但是由于内核稳定性比较高，一般只是会
将该内核模块杀死，并使系统维持在一个稳定状态；如果出现更严重情况，即内核出
现panic，就会宕机重启。
此时，读取/proc/kallsyms找到对应段地址的函数名。

* 表项格式
 #+BEGIN_EXAMPLE
 000000000479c4a0   A          phys_start
 符号地址           符号类型   符号名(函数或变量)
 #+END_EXAMPLE
其中符号类型可以参考文件${linux-src-path}/scripts/mksysmap; 大写为全局符号，
小写为局部符号
 - A  :: 符号值不能改变，等于const
 - B  :: 符号来自未初始化代码段bss段
 - C  :: 通用符号
    : 通用符号指未初始化的数据; 当链接时，多个通用符号可能对应一个名称，如
    : 果该符号在某一个位置定义，这个通用符号被当做未定义的引用
 - D  :: 符号位于初始化的数据段
 - G  :: 位于初始化数据段
    : 专门对应小的数据对象，比如global int x
    : 对应的大数据对象为数组类型等
 - I  :: 到其他符号的间接引用
    : 对a.out文件的GNU扩展，使用非常少
 - N  :: 调试符号
 - R  :: 只读代码段的符号
 - S  :: BSS段(未初始化数据段)的小对象符号
 - T  :: 代码段符号，全局函数，t为局部函数
 - U  :: 未定义的符号
 - V  :: weak object，当其连接到未定义的对象上，该符号的值变为0
 - W  :: 类似于V
 - —  :: 该符号是a.out文件中的一个stabs symbol，获取调试信息
 - ?  :: 未知类型的符号



